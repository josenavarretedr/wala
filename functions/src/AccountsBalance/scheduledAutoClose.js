/* eslint-disable */

/**
 * @file scheduledAutoClose.js
 * @description Funci√≥n programada que se ejecuta autom√°ticamente cada d√≠a a medianoche.
 * Cierra todos los d√≠as anteriores que quedaron abiertos sin cierre manual.
 * 
 * Infraestructura consistente con:
 * - useTransaction.js (creaci√≥n de transacciones)
 * - transactionStore.js (estructura de datos)
 * - useCashClosure.js (l√≥gica de cierre)
 * - accountsBalanceStore.js (c√°lculos financieros)
 * 
 * Se ejecuta mediante Cloud Scheduler de Firebase Functions v2
 * 
 * @module AccountsBalance/scheduledAutoClose
 */

const { onSchedule } = require('firebase-functions/v2/scheduler');
const admin = require('firebase-admin');
const { FieldValue } = require('firebase-admin/firestore');
const { v4: uuidv4 } = require('uuid');

// Inicializar Firebase Admin si no est√° inicializado
if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

const { yesterdayStr } = require('../Helpers/time');
const { getDayAggregates, upsertDailySummary } = require('./sharedComputed');
const { breakStreak, incStreakIfConsecutive } = require('./sharedStreak');

const DEFAULT_TZ = 'America/Lima';

/**
 * Funci√≥n programada que se ejecuta diariamente a las 00:05 (despu√©s de medianoche).
 * Procesa todos los negocios activos y cierra d√≠as pendientes autom√°ticamente.
 * 
 * Schedule: '5 0 * * *' = Diariamente a las 00:05 en timezone configurado
 * Timezone: America/Lima (UTC-5)
 * 
 * Casos de uso:
 * 1. D√≠a abierto sin cierre ‚Üí Crea cierre autom√°tico y rompe racha
 * 2. D√≠a completo (apertura + transacciones + cierre) ‚Üí Incrementa racha
 * 3. D√≠a sin apertura o sin actividad ‚Üí No hace nada
 * 
 * Logs: Se registran en Cloud Functions logs para auditor√≠a
 */
module.exports = onSchedule(
  {
    schedule: '5 0 * * *', // Diariamente a las 00:05 Lima
    timeZone: DEFAULT_TZ,
    retryCount: 3, // Reintentar hasta 3 veces en caso de error
    memory: '256MiB',
    timeoutSeconds: 540, // 9 minutos timeout
  },
  async (event) => {
    const startTime = Date.now();
    console.log('ü§ñ SCHEDULED AUTO-CLOSE START');
    console.log(`üïê Execution time: ${new Date().toISOString()}`);
    console.log(`üìÖ Schedule event ID: ${event.scheduleTime || 'N/A'}`);

    try {
      // Obtener todos los negocios activos
      const businessesSnapshot = await db.collection('businesses').get();
      console.log(`üìä Found ${businessesSnapshot.size} businesses to process`);

      const results = {
        total: businessesSnapshot.size,
        processed: 0,
        autoClosed: 0,
        streakIncreased: 0,
        noAction: 0,
        errors: 0
      };

      // Procesar cada negocio
      for (const businessDoc of businessesSnapshot.docs) {
        const businessId = businessDoc.id;
        const businessData = businessDoc.data();

        try {
          console.log(`\n${'='.repeat(60)}`);
          console.log(`üè™ Processing business: ${businessId}`);
          console.log(`   Name: ${businessData.name || 'N/A'}`);

          // Obtener timezone del negocio (o usar default)
          const tz = businessData.timezone || DEFAULT_TZ;
          console.log(`üåç Timezone: ${tz}`);

          // Calcular d√≠a anterior
          const day = yesterdayStr(tz);
          console.log(`üìÖ Checking day: ${day}`);

          // Obtener agregados del d√≠a
          const agg = await getDayAggregates(db, businessId, day, tz);
          console.log(`üìä Day status:`, {
            hasOpening: agg.hasOpening,
            hasClosure: agg.hasClosure,
            hasTxn: agg.hasTxn,
            totals: agg.totals,
            operational: agg.operational
          });

          // Actualizar resumen diario base con estructura completa
          await upsertDailySummary(db, businessId, day, {
            ...agg // Estructura completa de accountsBalanceStore
          });

          let action = 'none';
          let transactionId = null;

          // === CASO 1: D√çA ABIERTO SIN CIERRE ===
          if (agg.hasOpening && !agg.hasClosure) {
            console.log(`‚ö†Ô∏è  OPEN without closure - Creating automatic closure`);

            // Generar UUID para la transacci√≥n (consistente con useTransaction)
            const closureUuid = uuidv4();
            const closureRef = db.collection(`businesses/${businessId}/transactions`).doc(closureUuid);

            // Estructura de transacci√≥n consistente con transactionStore
            const closureTransaction = {
              uuid: closureUuid,
              type: 'closure',
              description: 'Cierre autom√°tico programado',
              source: 'copilot',
              copilotMode: 'scheduled',
              account: 'cash', // Default account
              amount: 0,
              // Metadata para trazabilidad completa
              metadata: {
                day: day,
                triggerType: 'scheduled_auto_close',
                autoGenerated: true,
                executionTime: new Date().toISOString(),
                aggregates: {
                  totalIncome: agg.totals.income,
                  totalExpense: agg.totals.expense,
                  netResult: agg.totals.net,
                  hasTransactions: agg.hasTxn
                }
              },
              createdAt: FieldValue.serverTimestamp()
            };

            // Crear transacci√≥n de cierre
            await closureRef.set(closureTransaction);
            console.log(`‚úÖ Closure created: ${closureUuid}`);

            // Actualizar resumen diario con info de cierre (merge sobre datos existentes)
            await upsertDailySummary(db, businessId, day, {
              hasClosure: true,
              isAutoClosed: true,
              closureId: closureUuid,
              autoCloseReason: 'scheduled',
              completedAt: FieldValue.serverTimestamp()
            });
            console.log(`‚úÖ Daily summary updated with closure info`);

            // Romper racha por cierre autom√°tico
            await breakStreak(db, businessId);
            console.log(`üìâ Streak broken`);

            results.autoClosed++;
            action = 'auto-closed';
            transactionId = closureUuid;
          }
          // === CASO 2: D√çA COMPLETO ===
          else if (agg.hasOpening && agg.hasTxn && agg.hasClosure) {
            console.log(`‚ú® Complete day - Incrementing streak`);
            await incStreakIfConsecutive(db, businessId, day, tz);
            console.log(`üìà Streak incremented`);
            results.streakIncreased++;
          }
          // === CASO 3: SIN ACCI√ìN NECESARIA ===
          else {
            console.log(`‚ÑπÔ∏è  No action needed`);
            if (!agg.hasOpening) console.log(`   - No opening found`);
            if (!agg.hasTxn) console.log(`   - No transactions found`);
            results.noAction++;
          }

          results.processed++;

        } catch (businessError) {
          console.error(`‚ùå Error processing business ${businessId}:`, businessError);
          console.error(`   Stack: ${businessError.stack}`);
          results.errors++;

          // Registrar error en Firestore para auditor√≠a
          await db.collection('system_logs').add({
            type: 'scheduled_auto_close_error',
            businessId,
            error: businessError.message,
            stack: businessError.stack,
            timestamp: FieldValue.serverTimestamp()
          });
        }
      }

      // === RESUMEN FINAL ===
      const duration = Date.now() - startTime;
      console.log(`\n${'='.repeat(60)}`);
      console.log('‚úÖ SCHEDULED AUTO-CLOSE COMPLETED');
      console.log(`‚è±Ô∏è  Duration: ${duration}ms (${(duration / 1000).toFixed(2)}s)`);
      console.log(`üìä Results:`, results);
      console.log(`   - Total: ${results.total}`);
      console.log(`   - Processed: ${results.processed}`);
      console.log(`   - Auto-closed: ${results.autoClosed}`);
      console.log(`   - Streak increased: ${results.streakIncreased}`);
      console.log(`   - No action: ${results.noAction}`);
      console.log(`   - Errors: ${results.errors}`);
      console.log(`üïê Finished at: ${new Date().toISOString()}`);

      // Guardar resumen de ejecuci√≥n en Firestore para an√°lisis
      await db.collection('scheduled_executions').add({
        type: 'auto_close',
        results,
        duration,
        timestamp: FieldValue.serverTimestamp(),
        success: true
      });

      return results;

    } catch (error) {
      const duration = Date.now() - startTime;
      console.error('‚ùå CRITICAL ERROR in scheduled auto-close:', error);
      console.error('Stack:', error.stack);
      console.log(`‚è±Ô∏è  Failed after: ${duration}ms`);

      // Guardar error cr√≠tico en Firestore
      await db.collection('scheduled_executions').add({
        type: 'auto_close',
        error: error.message,
        stack: error.stack,
        duration,
        timestamp: FieldValue.serverTimestamp(),
        success: false
      });

      throw error; // Re-throw para que Cloud Functions lo registre
    }
  }
);
