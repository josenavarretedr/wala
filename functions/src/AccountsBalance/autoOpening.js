/* eslint-disable */
// autoOpening.js

/**
 * @file autoOpening.js
 * @description Funci√≥n que genera autom√°ticamente una apertura de caja cuando no existe.
 * Se basa en el √∫ltimo cierre registrado para cargar los saldos iniciales.
 * 
 * Esta funci√≥n es llamada por scheduledAutoClose.js ANTES de procesar el cierre autom√°tico,
 * asegurando que siempre haya una apertura disponible para calcular los agregados.
 * 
 * Infraestructura consistente con:
 * - scheduledAutoClose.js (cierre autom√°tico programado - integraci√≥n completa)
 * - useTransaction.js (creaci√≥n de transacciones)
 * - transactionStore.js (estructura de datos)
 * - useCashClosure.js (l√≥gica de cierre)
 * - accountsBalanceStore.js (c√°lculos financieros)
 * 
 * Flujo de ejecuci√≥n:
 * 1. Verificar que NO exista apertura para el d√≠a especificado
 * 2. Buscar el cierre m√°s reciente (normalmente del d√≠a anterior)
 * 3. Copiar los saldos finales del cierre como saldos iniciales
 * 4. Crear transacci√≥n tipo 'opening' con fuente 'copilot'
 * 5. Actualizar resumen diario con la apertura autom√°tica
 * 6. Retornar resultado para que scheduledAutoClose contin√∫e con el cierre
 * 
 * @module AccountsBalance/autoOpening
 */

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const { FieldValue } = require('firebase-admin/firestore');
const { v4: uuidv4 } = require('uuid');

// Inicializar Firebase Admin si no est√° inicializado
if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

const { dateRangeForDay } = require('../Helpers/time');
const { getDayAggregates, upsertDailySummary } = require('./sharedComputed');

const DEFAULT_TZ = 'America/Lima';

/**
 * Busca el cierre m√°s reciente antes del d√≠a especificado.
 * 
 * @param {FirebaseFirestore.Firestore} db - Instancia de Firestore
 * @param {string} businessId - ID del negocio
 * @param {Date} beforeDate - Fecha l√≠mite (buscar antes de esta fecha)
 * 
 * @returns {Promise<Object|null>} Datos del √∫ltimo cierre o null si no existe
 * 
 * Estructura retornada:
 * {
 *   id: string,
 *   realCashBalance: number,
 *   realBankBalance: number,
 *   totalCash: number,
 *   totalBank: number,
 *   expectedCashBalance: number,
 *   expectedBankBalance: number,
 *   createdAt: Timestamp,
 *   day: string,
 *   ...resto de campos del closure
 * }
 */
async function findMostRecentClosure(db, businessId, beforeDate) {
  console.log(`üîç Searching for most recent closure before ${beforeDate.toISOString()}`);

  const closureSnap = await db.collection(`businesses/${businessId}/transactions`)
    .where('type', '==', 'closure')
    .where('createdAt', '<', beforeDate)
    .orderBy('createdAt', 'desc')
    .limit(1)
    .get();

  if (closureSnap.empty) {
    console.log(`‚ùå No previous closure found`);
    return null;
  }

  const closureDoc = closureSnap.docs[0];
  const closureData = { id: closureDoc.id, ...closureDoc.data() };

  console.log(`‚úÖ Found closure: ${closureData.id}`);
  console.log(`   üìÖ Created at: ${closureData.createdAt?.toDate()?.toISOString() || 'N/A'}`);
  console.log(`   üí∞ Real Cash: ${closureData.realCashBalance || closureData.totalCash || 0}`);
  console.log(`   üè¶ Real Bank: ${closureData.realBankBalance || closureData.totalBank || 0}`);

  return closureData;
}

/**
 * Crea una transacci√≥n de apertura autom√°tica basada en el √∫ltimo cierre.
 * 
 * @param {FirebaseFirestore.Firestore} db - Instancia de Firestore
 * @param {string} businessId - ID del negocio
 * @param {string} day - D√≠a para el cual crear la apertura ('yyyy-LL-dd')
 * @param {Object} lastClosure - Datos del √∫ltimo cierre
 * @param {string} tz - Timezone
 * 
 * @returns {Promise<string>} UUID de la transacci√≥n de apertura creada
 * 
 * Estructura de la transacci√≥n de apertura (consistente con useTransaction.js):
 * {
 *   uuid: string,
 *   type: 'opening',
 *   description: 'Apertura autom√°tica',
 *   source: 'copilot',
 *   copilotMode: 'auto_opening',
 *   
 *   // Saldos iniciales (copiados del cierre anterior)
 *   realCashBalance: number,
 *   realBankBalance: number,
 *   totalCash: number,
 *   totalBank: number,
 *   
 *   // Referencia al cierre del que se tomaron los datos
 *   previousClosureReference: string,
 *   
 *   // Metadata para trazabilidad
 *   metadata: {
 *     day: string,
 *     triggerType: 'auto_opening',
 *     autoGenerated: true,
 *     executionTime: string,
 *     previousClosureId: string,
 *     previousClosureDate: string
 *   },
 *   
 *   createdAt: Timestamp
 * }
 */
async function createAutoOpening(db, businessId, day, lastClosure, tz = DEFAULT_TZ) {
  console.log(`\nüöÄ Creating automatic opening for ${day}`);

  // Generar UUID para la transacci√≥n (consistente con useTransaction)
  const openingUuid = uuidv4();
  const openingRef = db.collection(`businesses/${businessId}/transactions`).doc(openingUuid);

  // Extraer saldos finales del √∫ltimo cierre
  // Priorizar realCashBalance/realBankBalance, luego totalCash/totalBank
  const cashBalance = lastClosure.realCashBalance ?? lastClosure.totalCash ?? 0;
  const bankBalance = lastClosure.realBankBalance ?? lastClosure.totalBank ?? 0;

  console.log(`üí∞ Initial balances from last closure:`);
  console.log(`   Cash: ${cashBalance}`);
  console.log(`   Bank: ${bankBalance}`);
  console.log(`   Total: ${cashBalance + bankBalance}`);

  // Estructura completa de apertura autom√°tica
  const openingTransaction = {
    uuid: openingUuid,
    type: 'opening',
    description: 'Apertura autom√°tica generada por el sistema',
    source: 'copilot',
    copilotMode: 'auto_opening',

    // Saldos iniciales (copiados del cierre anterior)
    realCashBalance: cashBalance,
    realBankBalance: bankBalance,
    totalCash: cashBalance,
    totalBank: bankBalance,

    // Campos compatibles con diferentes versiones del sistema
    cashAmount: cashBalance,
    bankAmount: bankBalance,
    amount: 0, // Apertura no tiene monto de transacci√≥n

    items: [],
    itemsAndStockLogs: [],

    // Referencia al cierre del que se tomaron los datos
    previousClosureReference: lastClosure.id,

    // Metadata para trazabilidad
    metadata: {
      day: day,
      triggerType: 'auto_opening',
      autoGenerated: true,
      executionTime: new Date().toISOString(),
      previousClosureId: lastClosure.id,
      previousClosureDate: lastClosure.createdAt?.toDate()?.toISOString() || 'N/A',
      timezone: tz
    },

    createdAt: FieldValue.serverTimestamp()
  };

  // Crear transacci√≥n de apertura
  await openingRef.set(openingTransaction);
  console.log(`‚úÖ Opening created: ${openingUuid}`);

  // Registrar en traceability_logs para trazabilidad completa
  await db.collection(`businesses/${businessId}/traceability_logs`).add({
    operationType: 'auto_opening',
    entityType: 'transaction',
    entityId: openingUuid,
    operation: 'automatic_opening',
    day,
    openingTransactionId: openingUuid,
    previousClosureId: lastClosure.id,
    triggerType: 'auto_opening',
    autoGenerated: true,
    financialData: {
      initialCashBalance: cashBalance,
      initialBankBalance: bankBalance,
      totalInitialBalance: cashBalance + bankBalance
    },
    executedAt: FieldValue.serverTimestamp(),
    timestamp: FieldValue.serverTimestamp()
  });

  console.log(`üìù Traceability log created`);

  return openingUuid;
}

/**
 * Funci√≥n principal de apertura autom√°tica.
 * Puede ser llamada desde otras Cloud Functions o endpoints HTTP.
 * 
 * @param {Object} params - Par√°metros de la funci√≥n
 * @param {string} params.businessId - ID del negocio
 * @param {string} params.day - D√≠a para crear apertura ('yyyy-LL-dd')
 * @param {string} [params.timezone] - Timezone (default: 'America/Lima')
 * 
 * @returns {Promise<Object>} Resultado de la operaci√≥n
 * {
 *   success: boolean,
 *   openingId: string | null,
 *   message: string,
 *   data: {
 *     day: string,
 *     businessId: string,
 *     openingId: string,
 *     previousClosureId: string,
 *     initialCashBalance: number,
 *     initialBankBalance: number
 *   }
 * }
 */
async function executeAutoOpening(params) {
  const { businessId, day, timezone = DEFAULT_TZ } = params;

  console.log(`\n${'='.repeat(60)}`);
  console.log(`ü§ñ AUTO OPENING EXECUTION START`);
  console.log(`${'='.repeat(60)}`);
  console.log(`üè™ Business ID: ${businessId}`);
  console.log(`üìÖ Day: ${day}`);
  console.log(`üåç Timezone: ${timezone}`);
  console.log(`üïê Execution time: ${new Date().toISOString()}`);

  try {
    // === PASO 1: Verificar que NO exista apertura ===
    console.log(`\nüìã STEP 1: Checking if opening already exists...`);

    const { start, end } = dateRangeForDay(day, timezone);

    const existingOpeningSnap = await db.collection(`businesses/${businessId}/transactions`)
      .where('type', '==', 'opening')
      .where('createdAt', '>=', start)
      .where('createdAt', '<=', end)
      .limit(1)
      .get();

    if (!existingOpeningSnap.empty) {
      const existingOpening = existingOpeningSnap.docs[0];
      console.log(`‚ö†Ô∏è  Opening already exists: ${existingOpening.id}`);
      console.log(`   Skipping auto-opening creation`);

      return {
        success: false,
        openingId: existingOpening.id,
        message: `Opening already exists for ${day}`,
        data: {
          day,
          businessId,
          openingId: existingOpening.id,
          alreadyExists: true
        }
      };
    }

    console.log(`‚úÖ No opening found - proceeding with auto-opening`);

    // === PASO 2: Buscar el cierre m√°s reciente ===
    console.log(`\nüìã STEP 2: Finding most recent closure...`);

    const lastClosure = await findMostRecentClosure(db, businessId, start);

    if (!lastClosure) {
      console.log(`‚ùå No previous closure found - cannot create auto-opening`);

      return {
        success: false,
        openingId: null,
        message: `No previous closure found for business ${businessId}`,
        data: {
          day,
          businessId,
          noPreviousClosure: true
        }
      };
    }

    console.log(`‚úÖ Previous closure found: ${lastClosure.id}`);

    // === PASO 3: Crear apertura autom√°tica ===
    console.log(`\nüìã STEP 3: Creating automatic opening...`);

    const openingId = await createAutoOpening(db, businessId, day, lastClosure, timezone);

    console.log(`‚úÖ Auto-opening created successfully: ${openingId}`);

    // === PASO 4: Recalcular agregados del d√≠a ===
    console.log(`\nüìã STEP 4: Recalculating day aggregates...`);

    const aggregates = await getDayAggregates(db, businessId, day, timezone);

    console.log(`‚úÖ Aggregates calculated:`, {
      hasOpening: aggregates.hasOpening,
      hasClosure: aggregates.hasClosure,
      hasTxn: aggregates.hasTxn
    });

    // === PASO 5: Actualizar resumen diario ===
    console.log(`\nüìã STEP 5: Updating daily summary...`);

    await upsertDailySummary(db, businessId, day, {
      ...aggregates,
      isAutoOpened: true,
      openingId: openingId,
      autoOpenReason: 'auto_opening',
      autoOpenedAt: FieldValue.serverTimestamp()
    });

    console.log(`‚úÖ Daily summary updated`);

    // === RESULTADO FINAL ===
    const result = {
      success: true,
      openingId: openingId,
      message: `Auto-opening created successfully for ${day}`,
      data: {
        day,
        businessId,
        openingId,
        previousClosureId: lastClosure.id,
        initialCashBalance: lastClosure.realCashBalance ?? lastClosure.totalCash ?? 0,
        initialBankBalance: lastClosure.realBankBalance ?? lastClosure.totalBank ?? 0,
        timezone
      }
    };

    console.log(`\n‚úÖ AUTO OPENING COMPLETED SUCCESSFULLY`);
    console.log(`${'='.repeat(60)}\n`);

    return result;

  } catch (error) {
    console.error(`\n‚ùå ========================================`);
    console.error(`‚ùå ERROR in auto-opening execution`);
    console.error(`‚ùå ========================================`);
    console.error(`Error:`, error.message);
    console.error(`Stack:`, error.stack);
    console.error(`‚ùå ========================================\n`);

    // Registrar error en Firestore
    await db.collection('systemLogs').add({
      type: 'auto_opening_error',
      businessId,
      day,
      error: error.message,
      stack: error.stack,
      timestamp: FieldValue.serverTimestamp()
    });

    throw error;
  }
}

/**
 * Cloud Function HTTP callable para ejecutar apertura autom√°tica.
 * Puede ser invocada desde el frontend o desde otras Cloud Functions.
 * 
 * Ejemplo de invocaci√≥n desde frontend:
 * ```javascript
 * const autoOpening = httpsCallable(functions, 'autoOpening');
 * const result = await autoOpening({
 *   businessId: 'abc123',
 *   day: '2025-10-21',
 *   timezone: 'America/Lima'
 * });
 * ```
 */
exports.autoOpening = functions
  .runWith({
    timeoutSeconds: 300, // 5 minutos timeout
    memory: '256MB'
  })
  .https
  .onCall(async (data, context) => {
    console.log(`üìû HTTP Callable invoked: autoOpening`);
    console.log(`   Caller:`, context.auth?.uid || 'unauthenticated');
    console.log(`   Data:`, data);

    // Validar par√°metros requeridos
    if (!data.businessId) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'businessId is required'
      );
    }

    if (!data.day) {
      throw new functions.https.HttpsError(
        'invalid-argument',
        'day is required (format: yyyy-LL-dd)'
      );
    }

    try {
      const result = await executeAutoOpening(data);
      return result;
    } catch (error) {
      console.error(`‚ùå Error in callable function:`, error);
      throw new functions.https.HttpsError(
        'internal',
        error.message,
        { originalError: error.stack }
      );
    }
  });

/**
 * Exportar funci√≥n interna para uso desde otras Cloud Functions
 */
exports.executeAutoOpening = executeAutoOpening;
