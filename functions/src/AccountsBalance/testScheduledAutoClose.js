/* eslint-disable */

/**
 * @file testScheduledAutoClose.js
 * @description Funci√≥n HTTP para testing del cierre autom√°tico programado.
 * Simula el comportamiento del scheduler que cierra d√≠as abiertos autom√°ticamente.
 * 
 * Infraestructura consistente con:
 * - useTransaction.js (creaci√≥n de transacciones)
 * - transactionStore.js (estructura de datos)
 * - useCashClosure.js (l√≥gica de cierre)
 * - accountsBalanceStore.js (c√°lculos financieros)
 * 
 * @module AccountsBalance/testScheduledAutoClose
 */

const functions = require('firebase-functions');
const admin = require('firebase-admin');
const { FieldValue } = require('firebase-admin/firestore');
const { v4: uuidv4 } = require('uuid');

if (!admin.apps.length) {
  admin.initializeApp();
}

const db = admin.firestore();

const { yesterdayStr } = require('../Helpers/time');
const { getDayAggregates, upsertDailySummary } = require('./sharedComputed');
const { breakStreak, incStreakIfConsecutive } = require('./sharedStreak');

const DEFAULT_TZ = 'America/Lima';

/**
 * Funci√≥n de testing para el cierre autom√°tico programado.
 * Procesa todos los negocios (o uno espec√≠fico) y cierra d√≠as pendientes.
 * 
 * Casos de uso:
 * 1. D√≠a abierto sin cierre ‚Üí Crea cierre autom√°tico
 * 2. D√≠a completo (apertura + transacciones + cierre) ‚Üí Incrementa racha
 * 3. D√≠a sin apertura o sin actividad ‚Üí No hace nada
 * 
 * Query params:
 * - businessId (opcional): Procesar solo un negocio espec√≠fico
 * 
 * Response:
 * - success: boolean
 * - results: Array con el resultado de cada negocio
 * - timestamp: ISO string
 */
module.exports = functions.https.onRequest(async (request, response) => {
  try {
    console.log('üß™ TEST: scheduledAutoClose');
    console.log(`üïê Started at: ${new Date().toISOString()}`);

    // Permite pasar un businessId espec√≠fico para testing
    const testBusinessId = request.query.businessId;

    let businesses;
    if (testBusinessId) {
      console.log(`üéØ Testing single business: ${testBusinessId}`);
      const doc = await db.doc(`businesses/${testBusinessId}`).get();

      if (!doc.exists) {
        console.error(`‚ùå Business ${testBusinessId} not found`);
        return response.status(404).json({
          success: false,
          error: `Negocio ${testBusinessId} no encontrado`
        });
      }

      businesses = { docs: [doc], size: 1 };
    } else {
      console.log(`üìä Testing all businesses`);
      businesses = await db.collection('businesses').get();
      console.log(`üìä Found ${businesses.size} businesses`);
    }

    const results = [];

    // Procesar cada negocio
    for (const b of businesses.docs) {
      if (!b.exists) {
        console.log('‚ö†Ô∏è  Document does not exist, skipping...');
        continue;
      }

      const businessId = b.id;
      const businessData = b.data();
      const tz = (businessData && businessData.timezone) || DEFAULT_TZ;

      console.log(`\n${'='.repeat(60)}`);
      console.log(`üè™ Business: ${businessId}`);
      console.log(`üåç Timezone: ${tz}`);

      // === CALCULAR D√çA ANTERIOR ===
      const day = yesterdayStr(tz);
      console.log(`üìÖ Processing day: ${day}`);

      // === OBTENER AGREGADOS DEL D√çA ===
      const agg = await getDayAggregates(db, businessId, day, tz);
      console.log(`üìä Aggregates:`, {
        hasOpening: agg.hasOpening,
        hasClosure: agg.hasClosure,
        hasTxn: agg.hasTxn,
        totals: agg.totals,
        operational: agg.operational
      });

      // Actualizar resumen diario con estructura completa
      await upsertDailySummary(db, businessId, day, {
        ...agg // Estructura completa de accountsBalanceStore
      });

      let action = 'none';
      let transactionId = null;

      // === CASO 1: D√çA ABIERTO SIN CIERRE ===
      if (agg.hasOpening && !agg.hasClosure) {
        console.log(`‚ö†Ô∏è  OPEN without closure - Creating automatic closure`);

        // Generar UUID para la transacci√≥n (consistente con useTransaction)
        const closureUuid = uuidv4();
        const closureRef = db.collection(`businesses/${businessId}/transactions`).doc(closureUuid);

        // Estructura de transacci√≥n consistente con transactionStore
        const closureTransaction = {
          uuid: closureUuid,
          type: 'closure',
          description: 'Cierre autom√°tico (scheduled)',
          source: 'copilot',
          copilotMode: 'scheduled',
          account: 'cash', // Default account
          amount: 0,
          // Metadata para trazabilidad
          metadata: {
            day: day,
            triggerType: 'scheduled_auto_close',
            autoGenerated: true,
            testMode: true,
            aggregates: {
              totalIncome: agg.totals.income,
              totalExpense: agg.totals.expense,
              netResult: agg.totals.net
            }
          },
          createdAt: FieldValue.serverTimestamp()
        };

        // Crear transacci√≥n de cierre
        await closureRef.set(closureTransaction);
        transactionId = closureUuid;
        console.log(`‚úÖ Closure created: ${closureUuid}`);

        // Actualizar resumen diario con info de cierre (merge sobre datos existentes)
        await upsertDailySummary(db, businessId, day, {
          hasClosure: true,
          isAutoClosed: true,
          closureId: closureUuid,
          autoCloseReason: 'test',
          completedAt: FieldValue.serverTimestamp()
        });
        console.log(`‚úÖ Daily summary updated with closure info`);

        // Romper racha
        await breakStreak(db, businessId);
        action = 'auto-closed';
        console.log(`üìâ Streak broken`);

      }
      // === CASO 2: D√çA COMPLETO ===
      else if (agg.hasOpening && agg.hasTxn && agg.hasClosure) {
        console.log(`‚ú® Complete day - Incrementing streak`);
        await incStreakIfConsecutive(db, businessId, day, tz);
        action = 'streak-increased';
        console.log(`üìà Streak incremented`);
      }
      // === CASO 3: SIN ACCI√ìN NECESARIA ===
      else {
        console.log(`‚ÑπÔ∏è  No action needed`);

        if (!agg.hasOpening) {
          console.log(`   - No opening found`);
        }
        if (!agg.hasTxn) {
          console.log(`   - No transactions found`);
        }
      }

      // Guardar resultado
      results.push({
        businessId,
        day,
        timezone: tz,
        action,
        transactionId,
        aggregates: {
          hasOpening: agg.hasOpening,
          hasClosure: agg.hasClosure,
          hasTransactions: agg.hasTxn,
          totals: agg.totals
        },
        timestamp: new Date().toISOString()
      });
    }

    console.log(`\n${'='.repeat(60)}`);
    console.log('‚úÖ TEST completed successfully');
    console.log(`üìä Processed ${results.length} businesses`);
    console.log(`üïê Finished at: ${new Date().toISOString()}`);

    // Resumen de acciones
    const summary = {
      total: results.length,
      autoClosed: results.filter(r => r.action === 'auto-closed').length,
      streakIncreased: results.filter(r => r.action === 'streak-increased').length,
      noAction: results.filter(r => r.action === 'none').length
    };

    console.log('üìà Summary:', summary);

    response.json({
      success: true,
      summary,
      results,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Error:', error);
    console.error('Stack:', error.stack);

    response.status(500).json({
      success: false,
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
});